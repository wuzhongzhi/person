4.1.0 JAVA中的几种基本数据类型是什么，各自占用多少字节。
long int byte boolean double float short char

4.1.1 String类能被继承吗，为什么。
不能 ，final
String a = new String("ab"); // a 为一个引用
String b = new String("ab"); // b为另一个引用,对象的内容一样
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true

4.1.2 String，Stringbuffer，StringBuilder的区别。
StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

4.1.4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。
类加载-》链接-》初始化-》使用-》卸载

4.1.5 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
4.1.6 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。
4.1.7 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。
4.1.8 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。
4.1.9 继承和聚合的区别在哪。
4.2.1 反射的原理，反射创建类实例的三种方式是什么。
4.2.2 反射中，Class.forName和ClassLoader区别 。
class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。注意这里的静态块指的是在类初始化时的一些数据。但是classloader却没有

4.2.3 描述动态代理的几种实现方式，分别说出相应的优缺点。
4.2.4 动态代理与cglib实现的区别。
4.2.5 为什么CGlib方式可以对接口实现代理。
4.2.6 final的用途。
4.2.7 写出三种单例模式实现 。
4.2.8 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。
4.2.9 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。
4.3.0 深拷贝和浅拷贝区别。
浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。 
深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

4.3.1 数组和链表数据结构描述，各自的时间复杂度。
4.3.2 error和exception的区别，CheckedException，RuntimeException的区别。
exception可以被处理，error不可被处理 尽量避免

4.3.3 请列出5个运行时异常。
数组越界、空指针、类型异常、非法参数、算术异常

4.3.4 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。

4.3.5 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。
当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置
equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。
两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。

4.3.6 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。
4.3.7 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。
4.3.8 有没有可能2个不相等的对象有相同的hashcode。
如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。 
如果两个对象的hashCode 值相等并且equals()方法返回 true，我们才认为这两个对象相等。
如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。


4.3.9 Java中的HashSet内部是如何工作的。
4.4.0 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。
4.4.1 java8的新特性。
