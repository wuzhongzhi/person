面试题：
1.JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。
2.线程加锁有哪些方式？synchronized和lock的区别？
3.乐观锁、悲观锁、互斥锁、读写锁的原理实现与区别
4.zookeeper分布式锁

如果synchronized修饰的是实例方法，对应的锁则是对象实例
如果synchronized修饰的是静态方法，对应的锁则是当前类的Class实例
如果synchronized修饰的是代码块，对应的锁则是传入synchronized的对象实例
在内存中，对象一般由三部分组成，分别是对象头、对象实际数据和对齐填充，Mark Word会记录对象关于锁的信息，每个对象都会有一个与之对应的monitor对象，monitor对象中存储着当前持有锁的线程以及等待锁的线程队列
Mark Word对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁
偏向锁指的就是JVM会认为只有某个线程才会执行同步代码（没有竞争的环境）
在轻量级锁状态下，当前线程会在栈帧下创建Lock Record，LockRecord 会把Mark Word的信息拷贝进去，且有个Owner指针指向加锁的对象线程执行到同步代码时，则用CAS试图将Mark Word的指向到线程栈帧的Lock Record，假设CAS修改成功，则获取得到轻量级锁
假设修改失败，则自旋（重试），自旋一定次数后，则升级为重量级锁
重量级锁用到monitor对象，而偏向锁则在Mark Word记录线程ID进行比对，轻量级锁则是拷贝Mark Word到Lock Record，用CAS+自旋的方式获取。

避免死锁的方式一般有以下方案：
固定加锁的顺序，比如我们可以使用Hash值的大小来确定加锁的先后
尽可能缩减加锁的范围，等到操作共享变量的时候才加锁。
使用可释放的定时锁（一段时间申请不到锁的权限了，直接释放掉）
